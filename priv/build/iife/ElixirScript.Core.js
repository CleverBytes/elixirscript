var _NumberisInteger=Number.isInteger,_StringfromCharCode=String.fromCharCode,ElixirScript=function(){'use strict';/* @flow */function namedVariableResult(E,F){return new NamedVariableResult(E,F)}/* @flow */function is_number(E){return'number'==typeof E}function is_string(E){return'string'==typeof E}function is_boolean(E){return'boolean'==typeof E}function is_symbol(E){return'symbol'==typeof E}function is_object(E){return'object'==typeof E}function is_variable(E){return E instanceof Variable}function is_null(E){return null===E}function is_array(E){return Array.isArray(E)}function is_function(E){return'[object Function]'==Object.prototype.toString.call(E)}function resolveNull(){return function(F){return is_null(F)}}function resolveWildcard(){return function(){return!0}}function resolveObject(E){let F={};const G=Object.keys(E).concat(Object.getOwnPropertySymbols(E));for(let H of G)F[H]=buildMatch(E[H]);return function(H,I){if(!is_object(H)||E.length>H.length)return!1;for(let J of G)if(!(J in H)||!F[J](H[J],I))return!1;return!0}}function getSize(E,F){return E*F/8}function arraysEqual(E,F){if(E===F)return!0;if(null==E||null==F)return!1;if(E.length!=F.length)return!1;for(var G=0;G<E.length;++G)if(E[G]!==F[G])return!1;return!0}function fillArray(E,F){for(let G=0;G<F;G++)E.push(0)}function createBitString(E){let F=E.map((G)=>h.integer(G));return new h(...F)}function resolveNoMatch(){return function(){return!1}}function buildMatch(E){if(null===E)return resolveNull(E);if('undefined'==typeof E)return resolveWildcard(E);const F=E.constructor.prototype,G=k.get(F);return G?G(E):'object'==typeof E?resolveObject(E):resolveNoMatch()}function defmatchgen(...E){const F=getArityMap(E);return function*(...G){let[H,I]=findMatchingFunction(G,F);return yield*H.apply(this,I)}}function findMatchingFunction(E,F){if(F.has(E.length)){const G=F.get(E.length);let H=null,I=null;for(let J of G){let K=[];E=fillInOptionalValues(E,J.arity,J.optionals);const L=J.pattern(E,K),[M,N]=checkNamedVariables(K);if(L&&N&&J.guard.apply(this,M)){H=J.fn,I=M;break}}if(!H)throw console.error('No match for:',E),new MatchError(E);return[H,I]}throw console.error('Arity of',E.length,'not found. No match for:',E),new MatchError(E)}function getArityMap(E){let F=new Map;for(const G of E){const H=getArityRange(G);for(const I of H){let J=[];F.has(I)&&(J=F.get(I)),J.push(G),F.set(I,J)}}return F}function getArityRange(E){const F=E.arity-E.optionals.length,G=E.arity;let H=[F];for(;H[H.length-1]!=G;)H.push(H[H.length-1]+1);return H}function getOptionalValues(E){let F=[];for(let G=0;G<E.length;G++)E[G]instanceof Variable&&E[G].default_value!=Symbol.for('tailored.no_value')&&F.push([G,E[G].default_value]);return F}function fillInOptionalValues(E,F,G){if(E.length===F||0===G.length)return E;if(E.length+G.length<F)return E;let H=F-E.length,I=G.length-H,J=G.slice(I);for(let[K,L]of J)if(E.splice(K,0,L),E.length===F)break;return E}function checkNamedVariables(E){const F={},G=[];for(let H=0;H<E.length;H++){const I=E[H];if(I instanceof NamedVariableResult){if(F[I.name]&&F[I.name]!==I.value)return[E,!1];F[I.name]&&F[I.name]===I.value?G.push(I.value):(F[I.name]=I.value,G.push(I.value))}else G.push(I)}return[G,!0]}function match_or_default(E,F,G=()=>!0,H=null){let I=[],J=buildMatch(E);const K=J(F,I),[L,M]=checkNamedVariables(I);return K&&M&&G.apply(this,L)?L:H}function run_generators(E,F){if(0==F.length)return E.map((G)=>{return Array.isArray(G)?G:[G]});const G=F.pop();let H=[];for(let I of G())for(let J of E)H.push([I].concat(J));return run_generators(H,F)}function iterator_to_reducer(E,F,G){const H=E[Symbol.iterator]();let I=H.next(),J=F;for(;!1===I.done;){if(J=G(I.value,J.get(1)),J.get(0)===Symbol.for('halt'))return new C.Tuple(Symbol.for('halted'),J.get(1));if(J.get(0)===Symbol.for('suspend'))return new C.Tuple(Symbol.for('suspended'),J.get(1),(K)=>{return iterator_to_reducer(H,K,G)});I=H.next()}return new C.Tuple(Symbol.for('done'),J.get(1))}function run_list_generators(E,F){if(0==F.length)return E.map((I)=>{return Array.isArray(I)?I:[I]});const G=F.pop(),H=[];for(const I of G())for(const J of E)H.push([I].concat(J));return run_list_generators(H,F)}// http://erlang.org/doc/man/erlang.html
function atom_to_binary(E,F=Symbol.for('utf8')){if(F!==Symbol.for('utf8'))throw new Error(`unsupported encoding ${F}`);return E.__MODULE__?Symbol.keyFor(E.__MODULE__):Symbol.keyFor(E)}function binary_to_atom(E,F=Symbol.for('utf8')){if(F!==Symbol.for('utf8'))throw new Error(`unsupported encoding ${F}`);return Symbol.for(E)}function is_number$1(E){return'number'==typeof E||E instanceof Number}function to_list(E){if(!1===q.is_map(E))return new g.Tuple(u,E);const F=[];for(const G of keys(E))F.push(new g.Tuple(G,E[G]));return F}function keys(E){if(!1===q.is_map(E))return new g.Tuple(u,E);const F=[];for(const G of Object.getOwnPropertySymbols(E))F.push(G);for(const G of Object.getOwnPropertyNames(E))F.push(G);return F}function is_key(E,F){return F.hasOwnProperty(E)}// http://erlang.org/doc/man/lists.html
function reverse(E){return[...E].reverse()}function flatten(E,F=[]){const G=E.reduce((H,I)=>{return Array.isArray(I)?H.concat(flatten(I)):H.concat(I)},[]);return G.concat(F)}function foldl(E,F,G){return G.reduce((H,I)=>{return E(I,H)},F)}function keyfind(E,F,G){for(const H of G)if(H.get(F-1)===E)return H;return!1}function keydelete(E,F,G){const H=[];let I=!1;for(let J=0;J<G.length;J++)!1==I&&G[J].get(F-1)===E?I=!0:H.push(G[J]);return H}function get_key(E){let F=E;if(__elixirscript_names__.has(E)&&(F=__elixirscript_names__.get(E)),__elixirscript_store__.has(F))return F;throw new Error(`Key ${F} not found`)}class Variable{constructor(E=null,F=Symbol.for('tailored.no_value')){this.name=E,this.default_value=F}}class Wildcard{constructor(){}}class StartsWith{constructor(E){this.prefix=E}}class Capture{constructor(E){this.value=E}}class HeadTail{constructor(){}}class Type{constructor(E,F={}){this.type=E,this.objPattern=F}}class Bound{constructor(E){this.value=E}}class BitStringMatch{constructor(...E){this.values=E}length(){return values.length}bit_size(){return 8*this.byte_size()}byte_size(){let E=0;for(let F of this.values)E+=F.unit*F.size/8;return E}getValue(E){return this.values(E)}getSizeOfValue(E){let F=this.getValue(E);return F.unit*F.size}getTypeOfValue(E){return this.getValue(E).type}}class NamedVariableResult{constructor(E,F){this.name=E,this.value=F}}class Tuple{constructor(...E){this.values=Object.freeze(E),this.length=this.values.length}get(E){return this.values[E]}count(){return this.values.length}[Symbol.iterator](){return this.values[Symbol.iterator]()}toString(){let E,F='';for(E=0;E<this.values.length;E++){''!=F&&(F+=', ');const G=this.values[E]?this.values[E].toString():'';F+=G}return'{'+F+'}'}put_elem(E,F){if(E===this.length){let H=this.values.concat([F]);return new Tuple(...H)}let G=this.values.concat([]);return G.splice(E,0,F),new Tuple(...G)}remove_elem(E){let F=this.values.concat([]);return F.splice(E,1),new Tuple(...F)}}let c=-1,d=-1;class BitString$1{constructor(...E){this.value=Object.freeze(this.process(E)),this.length=this.value.length,this.bit_size=8*this.length,this.byte_size=this.length}get(E){return this.value[E]}count(){return this.value.length}slice(E,F=null){let G=this.value.slice(E,F),H=G.map((I)=>BitString$1.integer(I));return new BitString$1(...H)}[Symbol.iterator](){return this.value[Symbol.iterator]()}toString(){var E,F='';for(E=0;E<this.count();E++)''!=F&&(F+=', '),F+=this.get(E).toString();return'<<'+F+'>>'}process(E){let F=[];var G;for(G=0;G<E.length;G++){let H=this['process_'+E[G].type](E[G]);for(let I of E[G].attributes)H=this['process_'+I](H);F=F.concat(H)}return F}process_integer(E){return E.value}process_float(E){if(64===E.size)return BitString$1.float64ToBytes(E.value);if(32===E.size)return BitString$1.float32ToBytes(E.value);throw new Error('Invalid size for float')}process_bitstring(E){return E.value.value}process_binary(E){return BitString$1.toUTF8Array(E.value)}process_utf8(E){return BitString$1.toUTF8Array(E.value)}process_utf16(E){return BitString$1.toUTF16Array(E.value)}process_utf32(E){return BitString$1.toUTF32Array(E.value)}process_signed(E){return new Uint8Array([E])[0]}process_unsigned(E){return E}process_native(E){return E}process_big(E){return E}process_little(E){return E.reverse()}process_size(E){return E}process_unit(E){return E}static integer(E){return BitString$1.wrap(E,{type:'integer',unit:1,size:8})}static float(E){return BitString$1.wrap(E,{type:'float',unit:1,size:64})}static bitstring(E){return BitString$1.wrap(E,{type:'bitstring',unit:1,size:E.bit_size})}static bits(E){return BitString$1.bitstring(E)}static binary(E){return BitString$1.wrap(E,{type:'binary',unit:8,size:E.length})}static bytes(E){return BitString$1.binary(E)}static utf8(E){return BitString$1.wrap(E,{type:'utf8',unit:1,size:E.length})}static utf16(E){return BitString$1.wrap(E,{type:'utf16',unit:1,size:2*E.length})}static utf32(E){return BitString$1.wrap(E,{type:'utf32',unit:1,size:4*E.length})}static signed(E){return BitString$1.wrap(E,{},'signed')}static unsigned(E){return BitString$1.wrap(E,{},'unsigned')}static native(E){return BitString$1.wrap(E,{},'native')}static big(E){return BitString$1.wrap(E,{},'big')}static little(E){return BitString$1.wrap(E,{},'little')}static size(E,F){return BitString$1.wrap(E,{size:F})}static unit(E,F){return BitString$1.wrap(E,{unit:F})}static wrap(E,F,G=null){let H=E;return E instanceof Object||(H={value:E,attributes:[]}),H=Object.assign(H,F),G&&H.attributes.push(G),H}static toUTF8Array(E){for(var H,F=[],G=0;G<E.length;G++)H=E.charCodeAt(G),128>H?F.push(H):2048>H?F.push(192|H>>6,128|63&H):55296>H||57344<=H?F.push(224|H>>12,128|63&H>>6,128|63&H):(G++,H=65536+((1023&H)<<10|1023&E.charCodeAt(G)),F.push(240|H>>18,128|63&H>>12,128|63&H>>6,128|63&H));return F}static toUTF16Array(E){for(var H,F=[],G=0;G<E.length;G++)H=E.codePointAt(G),255>=H?(F.push(0),F.push(H)):(F.push(255&H>>8),F.push(255&H));return F}static toUTF32Array(E){for(var H,F=[],G=0;G<E.length;G++)H=E.codePointAt(G),255>=H?(F.push(0),F.push(0),F.push(0),F.push(H)):(F.push(0),F.push(0),F.push(255&H>>8),F.push(255&H));return F}//http://stackoverflow.com/questions/2003493/javascript-float-from-to-bits
static float32ToBytes(E){var F=[],G=new ArrayBuffer(4);new Float32Array(G)[0]=E;let H=new Uint32Array(G)[0];return F.push(255&H>>24),F.push(255&H>>16),F.push(255&H>>8),F.push(255&H),F}static float64ToBytes(E){var F=[],G=new ArrayBuffer(8);new Float64Array(G)[0]=E;var H=new Uint32Array(G)[0],I=new Uint32Array(G)[1];return F.push(255&I>>24),F.push(255&I>>16),F.push(255&I>>8),F.push(255&I),F.push(255&H>>24),F.push(255&H>>16),F.push(255&H>>8),F.push(255&H),F}}var g={Tuple,PID:class PID{constructor(){++c,this.id=c}toString(){return'PID#<0.'+this.id+'.0>'}},Reference:class Reference{constructor(){++d,this.id=d,this.ref=Symbol()}toString(){return'Ref#<0.0.0.'+this.id+'>'}},BitString:BitString$1};/* @flow */const h=g.BitString,k=new Map;k.set(Variable.prototype,function resolveVariable(E){return function(F,G){return null===E.name||E.name.startsWith('_')?G.push(F):G.push(namedVariableResult(E.name,F)),!0}}),k.set(Wildcard.prototype,resolveWildcard),k.set(HeadTail.prototype,function resolveHeadTail(){return function(E,F){if(!is_array(E)||2>E.length)return!1;const G=E[0],H=E.slice(1);return F.push(G),F.push(H),!0}}),k.set(StartsWith.prototype,function resolveStartsWith(E){const F=E.prefix;return function(G,H){return is_string(G)&&G.startsWith(F)&&(H.push(G.substring(F.length)),!0)}}),k.set(Capture.prototype,function resolveCapture(E){const F=buildMatch(E.value);return function(G,H){return!!F(G,H)&&(H.push(G),!0)}}),k.set(Bound.prototype,function resolveBound(E){return function(F){return typeof F==typeof E.value&&F===E.value}}),k.set(Type.prototype,function resolveType(E){return function(F,G){if(F instanceof E.type){const H=buildMatch(E.objPattern);return H(F,G)}return!1}}),k.set(BitStringMatch.prototype,function resolveBitString(E){let F=[];for(let H of E.values)if(is_variable(H.value)){let I=getSize(H.unit,H.size);fillArray(F,I)}else F=F.concat(new h(H).value);let G=E.values;return function(H,I){let J=null;if(!is_string(H)&&!(H instanceof h))return!1;J=is_string(H)?new h(h.binary(H)):H;let K=0;for(let M,L=0;L<G.length;L++){if(M=G[L],is_variable(M.value)&&'binary'==M.type&&void 0===M.size&&L<G.length-1)throw new Error('a binary field without size is only allowed at the end of a binary pattern');let N=0,O=[],P=[];if(N=getSize(M.unit,M.size),L===G.length-1?(O=J.value.slice(K),P=F.slice(K)):(O=J.value.slice(K,K+N),P=F.slice(K,K+N)),is_variable(M.value))switch(M.type){case'integer':M.attributes&&-1!=M.attributes.indexOf('signed')?I.push(new Int8Array([O[0]])[0]):I.push(new Uint8Array([O[0]])[0]);break;case'float':if(64==N)I.push(Float64Array.from(O)[0]);else if(32==N)I.push(Float32Array.from(O)[0]);else return!1;break;case'bitstring':I.push(createBitString(O));break;case'binary':I.push(_StringfromCharCode.apply(null,new Uint8Array(O)));break;case'utf8':I.push(_StringfromCharCode.apply(null,new Uint8Array(O)));break;case'utf16':I.push(_StringfromCharCode.apply(null,new Uint16Array(O)));break;case'utf32':I.push(_StringfromCharCode.apply(null,new Uint32Array(O)));break;default:return!1;}else if(!arraysEqual(O,P))return!1;K+=N}return!0}}),k.set(Number.prototype,function resolveNumber(E){return function(F){return is_number(F)&&F===E}}),k.set(Symbol.prototype,function resolveSymbol(E){return function(F){return is_symbol(F)&&F===E}}),k.set(Array.prototype,function resolveArray(E){const F=E.map((G)=>buildMatch(G));return function(G,H){return is_array(G)&&G.length==E.length&&G.every(function(I,J){return F[J](G[J],H)})}}),k.set(String.prototype,function resolveString(E){return function(F){return is_string(F)&&F===E}}),k.set(Boolean.prototype,function resolveBoolean(E){return function(F){return is_boolean(F)&&F===E}}),k.set(Function.prototype,function resolveFunction(E){return function(F){return is_function(F)&&F===E}}),k.set(Object.prototype,resolveObject);class MatchError extends Error{constructor(E){if(super(),'symbol'==typeof E)this.message='No match for: '+E.toString();else if(Array.isArray(E)){let F=E.map((G)=>{return null===G?'null':'undefined'==typeof G?'undefined':G.toString()});this.message='No match for: '+F}else this.message='No match for: '+E;this.stack=new Error().stack,this.name=this.constructor.name}}class Clause{constructor(E,F,G=()=>!0){this.pattern=buildMatch(E),this.arity=E.length,this.optionals=getOptionalValues(E),this.fn=F,this.guard=G}}const l=Symbol();// https://github.com/airportyh/protomorphism
class Protocol{constructor(E){function createFun(F){return function(...G){const H=G[0];let I=null;if(null===H&&this.hasImplementation(Symbol('null'))?I=this.registry.get(Symbol)[F]:_NumberisInteger(H)&&this.hasImplementation(C.Integer)?I=this.registry.get(C.Integer)[F]:'number'==typeof H&&!_NumberisInteger(H)&&this.hasImplementation(C.Float)?I=this.registry.get(C.Float)[F]:'string'==typeof H&&this.hasImplementation(C.BitString)?I=this.registry.get(C.BitString)[F]:H&&H[Symbol.for('__struct__')]&&this.hasImplementation(H)?I=this.registry.get(H[Symbol.for('__struct__')].__MODULE__)[F]:null!==H&&this.hasImplementation(H)?I=this.registry.get(H.constructor)[F]:this.fallback&&(I=this.fallback[F]),null!=I){const J=I.apply(this,G);return J}throw new Error(`No implementation found for ${H}`)}}for(const F in this.registry=new Map,this.fallback=null,E)this[F]=createFun(F).bind(this)}implementation(E,F){null===E?this.fallback=F:this.registry.set(E,F)}hasImplementation(E){return E===C.Integer||E===C.Float||E===C.BitString?this.registry.has(E):E&&E[Symbol.for('__struct__')]?this.registry.has(E[Symbol.for('__struct__')].__MODULE__):this.registry.has(E.constructor)}}var q={atom_to_binary,binary_to_atom,binary_to_existing_atom:function binary_to_existing_atom(E,F=Symbol.for('utf8')){return binary_to_atom(E,F)},list_concatenation:function list_concatenation(E,F){return E.concat(F)},list_subtraction:function list_subtraction(E,F){const G=[...E];for(const H of F){const I=G.indexOf(H);-1<I&&G.splice(I,1)}return G},plus:function plus(E,F){return F?E+F:+E},minus:function minus(E,F){return F?E-F:-E},multiply:function multiply(E,F){return E*F},div:function div(E,F){return E/F},equal:function equal(E,F){return E==F},greaterThan:function greaterThan(E,F){return E>F},greaterThanOrEqualTo:function greaterThanOrEqualTo(E,F){return E>=F},lessThan:function lessThan(E,F){return E<F},lessThanOrEqualTo:function lessThanOrEqualTo(E,F){return E<=F},doesNotEqual:function doesNotEqual(E,F){return E!=F},strictlyEqual:function strictlyEqual(E,F){return E===F},doesNotStrictlyEqual:function doesNotStrictlyEqual(E,F){return E!==F},and:function and(E,F){return E&&F},or:function or(E,F){return E||F},not:function not(E){return!E},rem:function rem(E,F){return E%F},band:function band(E,F){return E&F},bor:function bor(E,F){return E|F},bsl:function bsl(E,F){return E<<F},bsr:function bsr(E,F){return E>>F},bxor:function bxor(E,F){return E^F},bnot:function bnot(E){return~E},is_bitstring:function is_bitstring$1(E){return E instanceof g.BitString},is_boolean:function is_boolean$1(E){return'boolean'==typeof E||E instanceof Boolean},is_float:function is_float(E){return is_number$1(E)&&!_NumberisInteger(E)},is_function:function is_function$1(E){return'function'==typeof E||E instanceof Function},is_integer:function is_integer(E){return _NumberisInteger(E)},is_list:function is_list(E){return Array.isArray(E)},is_map:function is_map(E){return'object'==typeof E||E instanceof Object},is_number:is_number$1,is_pid:function is_pid(E){return E instanceof g.PID},is_port:function is_port(){return!1},is_reference:function is_reference(E){return E instanceof g.Reference},is_tuple:function is_tuple(E){return E instanceof g.Tuple},is_atom:function is_atom(E){return'symbol'==typeof E||E instanceof Symbol||E.__MODULE__},is_binary:function is_binary(E){return'string'==typeof E||E instanceof String},element:function element(E,F){return F.get(E-1)},setelement:function setelement(E,F,G){const H=[...F.values];return H[E-1]=G,new g.Tuple(...H)},make_tuple:function make_tuple(E,F){const G=[];for(let H=0;H<E;H++)G.push(F);return new g.Tuple(...G)},insert_element:function insert_element(E,F,G){const H=[...F.values];return H.splice(E-1,0,G),new g.Tuple(...H)},append_element:function append_element(E,F){const G=[...E.values,F];return new g.Tuple(...G)},delete_element:function delete_element(E,F){const G=[...F.values];return G.splice(E-1,1),new g.Tuple(...G)},tuple_to_list:function tuple_to_list(E){const F=[...E.values];return F},abs:function abs(E){return Math.abs(E)},apply:function apply(...E){return 2===E.length?E[0].apply(this,...E[1]):E[0][atom_to_binary(E[1])].apply(this,...E[2])},binary_part:function binary_part(E,F,G){return E.substring(F,F+G)},bit_size:function bit_size(E){return E.bit_size},byte_size:function byte_size(E){return E.byte_size},hd:function hd(E){return E[0]},length:function length(E){return E.length},make_ref:function make_ref(){return new g.Reference},map_size:function map_size(E){return Object.keys(E).length},max:function max(E,F){return Math.max(E,F)},min:function min(E,F){return Math.min(E,F)},round:function round(E){return Math.round(E)},tl:function tl(E){return E.slice(1)},trunc:function trunc(E){return Math.trunc(E)},tuple_size:function tuple_size(E){return E.length},binary_to_float:function binary_to_float(E){return parseFloat(E)},binary_to_integer:function binary_to_integer(E,F=10){return parseInt(E,F)}};// http://erlang.org/doc/man/maps.html
const r=Symbol.for('ok'),t=Symbol.for('error'),u=Symbol.for('badmap'),w=Symbol.for('badkey'),B=function get_global(){return'undefined'==typeof self?'undefined'==typeof window?'undefined'==typeof global?(console.warn('No global state found'),null):global:window:self}();B.__elixirscript_store__=new Map,B.__elixirscript_names__=new Map;var C={Tuple:g.Tuple,PID:g.PID,BitString:g.BitString,Patterns:{defmatch:function defmatch(...E){const F=getArityMap(E);return function(...G){let[H,I]=findMatchingFunction(G,F);return H.apply(this,I)}},match:function match(E,F,G=()=>!0){let H=[],I=buildMatch(E);const J=I(F,H),[K,L]=checkNamedVariables(H);if(J&&L&&G.apply(this,K))return K;throw console.error('No match for:',F),new MatchError(F)},MatchError,variable:function variable(E=null,F=Symbol.for('tailored.no_value')){return new Variable(E,F)},wildcard:function wildcard(){return new Wildcard},startsWith:function startsWith(E){return new StartsWith(E)},capture:function capture(E){return new Capture(E)},headTail:function headTail(){return new HeadTail},type:function type(E,F={}){return new Type(E,F)},bound:function bound(E){return new Bound(E)},Clause,clause:function clause(E,F,G=()=>!0){return new Clause(E,F,G)},bitStringMatch:function bitStringMatch(...E){return new BitStringMatch(...E)},match_or_default,defmatchgen,list_comprehension:function list_comprehension(E,F){const G=run_generators(F.pop()(),F);let H=[];for(let I of G)E.guard.apply(this,I)&&H.push(E.fn.apply(this,I));return H},list_generator:function list_generator(E,F){return function(){let G=[];for(let H of F){const I=match_or_default(E,H,()=>!0,l);if(I!=l){const[J]=I;G.push(J)}}return G}},bitstring_generator:function bitstring_generator(E,F){return function(){let G=[],H=F.slice(0,E.byte_size()),I=1;for(;H.byte_size==E.byte_size();){const J=match_or_default(E,H,()=>!0,l);J!=l&&G.push(J),H=F.slice(E.byte_size()*I,E.byte_size()*(I+1)),I++}return G}},bitstring_comprehension:function bitstring_comprehension(E,F){const G=run_generators(F.pop()(),F);let H=[];for(let I of G)E.guard.apply(this,I)&&H.push(E.fn.apply(this,I));return H=H.map((I)=>g.BitString.integer(I)),new g.BitString(...H)},defmatchGen:function defmatchGen(...E){return defmatchgen(...E)},defmatchAsync:function defmatchAsync(...E){const F=getArityMap(E);return async function(...G){if(F.has(G.length)){const H=F.get(G.length);let I=null,J=null;for(let K of H){let L=[];G=fillInOptionalValues(G,K.arity,K.optionals);const M=K.pattern(G,L),[N,O]=checkNamedVariables(L);if(M&&O&&(await K.guard.apply(this,L))){I=K.fn,J=L;break}}if(!I)throw console.error('No match for:',G),new MatchError(G);return I.apply(this,J)}throw console.error('Arity of',G.length,'not found. No match for:',G),new MatchError(G)}}},Integer:class Integer{},Float:class Float{},Functions:{call_property:function call_property(E,F){if(!F)return E instanceof Function||'function'==typeof E?E():E;let G=null;if('number'==typeof E||'symbol'==typeof E||'boolean'==typeof E||'string'==typeof E?void 0===E[F]?void 0!==E[Symbol.for(F)]&&(G=Symbol.for(F)):G=F:F in E?G=F:Symbol.for(F)in E&&(G=Symbol.for(F)),null===G)throw new Error(`Property ${F} not found in ${E}`);return E[G]instanceof Function||'function'==typeof E[G]?E[G]():E[G]},defprotocol:function defprotocol(E){return new Protocol(E)},defimpl:function defimpl(E,F,G){E.implementation(F,G)},build_namespace:function build_namespace(E,F){let G=F.split('.');const H=E;let I=E;'Elixir'===G[0]&&(G=G.slice(1));for(const J of G)'undefined'==typeof I[J]&&(I[J]={}),I=I[J];return H.__table__=E.__table__||{},H.__table__[Symbol.for(F)]=I,I},iterator_to_reducer},SpecialForms:{_case:function _case(E,F){return C.Patterns.defmatch(...F)(E)},cond:function cond(...E){for(const F of E)if(F[0])return F[1]();throw new Error},_for:function _for(E,F,G,H=[]){let[I,J]=G.into(H);const K=run_list_generators(F.pop()(),F);for(const L of K)E.guard.apply(this,L)&&(I=J(I,new C.Tuple(Symbol.for('cont'),E.fn.apply(this,L))));return J(I,Symbol.for('done'))},_try:function _try(E,F,G,H,I){let J=null;try{J=E()}catch(K){let L=null;if(F)try{return L=F(K),L}catch(M){if(M instanceof C.Patterns.MatchError)throw M}if(G)try{return L=G(K),L}catch(M){if(M instanceof C.Patterns.MatchError)throw M}throw K}finally{I&&I()}if(H)try{return H(J)}catch(K){if(K instanceof C.Patterns.MatchError)throw new Error('No Match Found in Else');throw K}else return J},_with:function _with(...E){let F=[],G=null,H=null;'function'==typeof E[E.length-2]?[G,H]=E.splice(-2):G=E.pop();for(let I=0;I<E.length;I++){const[J,K]=E[I],L=K(...F),M=C.Patterns.match_or_default(J,L);if(null==M)return H?H.call(null,L):L;F=F.concat(M)}return G(...F)},receive:function receive(){console.warn('Receive not supported')}},Store:{create:function create(E,F=null){const G=new C.PID;return null!==F&&__elixirscript_names__.set(F,G),__elixirscript_store__.set(G,E)},update:function update$1(E,F){const G=get_key(E);return __elixirscript_store__.set(G,F)},read:function read(E){const F=get_key(E);return __elixirscript_store__.get(F)},remove:function remove$1(E){const F=get_key(E);return __elixirscript_store__.delete(F)}},global:B,erlang:q,maps:{find:function find(E,F){if(!1===q.is_map(F))return new g.Tuple(u,F);const G=F[E];return'undefined'==typeof G?t:new g.Tuple(r,G)},fold:function fold(E,F,G){let H=F;for(const[I,J]of to_list(G))H=E(I,J,H);return H},remove:function remove(E,F){if(!1===q.is_map(F))return new g.Tuple(u,F);const G=Object.assign({},F);return delete G[E],G},to_list,from_list:function from_list(E){return E.reduce((F,G)=>{const[H,I]=G;return F[H]=I,F},{})},keys,values:function values$1(E){if(!1===q.is_map(E))return new g.Tuple(u,E);const F=[];for(const G of keys(E))F.push(E[G]);return F},is_key,put:function put(E,F,G){if(!1===q.is_map(G))return new g.Tuple(u,G);const H=Object.assign({},G,{[E]:F});return H},merge:function merge(E,F){return!1===q.is_map(E)?new g.Tuple(u,E):!1===q.is_map(F)?new g.Tuple(u,F):Object.assign({},E,F)},update:function update(E,F,G){return!1===q.is_map(G)?new g.Tuple(u,G):!1===is_key(E,G)?new g.Tuple(w,E):Object.assign({},G,{[E]:F})},get:function get(...E){const F=E[0],G=E[1];return!1===q.is_map(G)?new g.Tuple(u,G):is_key(F)?G[F]:3===E.length?E[2]:new g.Tuple(w,F)},take:function take(E,F){if(!1===q.is_map(F))return new g.Tuple(u,F);if(!is_key(E))return t;const G=F[E],H=Object.assign({},F);return delete H[E],new g.Tuple(G,H)}},lists:{reverse,foreach:function foreach(E,F){return F.forEach((G)=>E(G)),Symbol.for('ok')},duplicate:function duplicate(E,F){const G=[];for(;G.length<E;)G.push(F);return G},flatten,foldl,foldr:function foldr(E,F,G){return foldl(E,F,reverse(G))},keydelete,keyfind,keymember:function keymember(E,F,G){return!1!==keyfind(E,F,G)},keyreplace:function keyreplace(E,F,G,H){const I=[...G];for(let J=0;J<I.length;J++)if(I[J].get(F-1)===E)return I[J]=H,I;return I},keysort:function keysort(E,F){const G=[...F];return G.sort((H,I)=>{return H.get(E-1)<I.get(E-1)?-1:H.get(E-1)>I.get(E-1)?1:0})},keystore:function keystore(E,F,G,H){const I=[...G];for(let J=0;J<I.length;J++)if(I[J].get(F-1)===E)return I[J]=H,I;return I.concat(H)},keytake:function keytake(E,F,G){const H=keyfind(E,F,G);return!1!==H&&new g.Tuple(H.get(F-1),H,keydelete(E,F,G))},mapfoldl:function mapfoldl(E,F,G){const H=[];let I=F;for(const J of G){const K=E(J,I);H.push(K.get(0)),I=K.get(1)}return new g.Tuple(H,I)},concat:function concat(E){return E.map((F)=>F.toString()).join()},map:function map(E,F){return F.map((G)=>E(G))},filter:function filter(E,F){return F.filter((G)=>E(G))},filtermap:function filtermap(E,F){const G=[];for(const H of F){const I=E(H);!0===I?G.push(H):I instanceof g.Tuple&&!0===I.get(0)&&G.push(I.get(1))}return G},member:function member(E,F){for(const G of F)if(G===E)return!0;return!1},all:function all(E,F){for(const G of F)if(!1===E(G))return!1;return!0},any:function any(E,F){for(const G of F)if(!0===E(G))return!0;return!1},splitwith:function splitwith(E,F){let G=!1;const H=[],I=[];for(const J of F)!0==G?I.push(J):!0===E(J)?H.push(J):(G=!0,I.push(J));return new g.Tuple(H,I)},sort:function sort(...E){if(1===E.length){const H=[...E[0]];return H.sort()}const F=E[0],G=[...E[1]];return G.sort((H,I)=>{const J=F(H,I);return!0===J?-1:1})}}};return{Core:C}}();
